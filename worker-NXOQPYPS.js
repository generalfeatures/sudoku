function h(r){let t=[],e=r.getSolutionStructure(),n=0,a=0,l=r.universe,c=JSON.parse(JSON.stringify(r.universe));for(;;){if(n++,r.maxIteration>0&&n>r.maxIteration)throw new Error("maxIteration reached.");if(a===-1){if(r.strategy==="find-all")break;throw new Error("it seems that the backtracking cannot find a solution.")}let i=r.getPossibilities(l,a);if(i.length===0){r.resetSolution(e,a),r.resetPossibilities(i,a,c),a--;continue}let o=r.pop(i);if(r.setSolution(e,a,o),r.checkSolution(e,a))a++;else continue;if(a===r.length){if(r.strategy==="find-first")break;if(r.strategy==="find-all"){let y=JSON.parse(JSON.stringify(e));if(t.push(y),t.length>=r.max)break;a--;continue}}}if(r.strategy==="find-first")return e;if(r.strategy==="find-all")return t}var f=class f{static deepClone(t){return JSON.parse(JSON.stringify(t))}static popRand(t){if(t.length===0)throw new Error("cannot pop from an empty array");let e=Math.floor(Math.random()*t.length),n=t[e];return t.splice(e,1),n}static initGrid(){return new Array(9).fill(0).map(()=>new Array(9).fill(0))}static makeGridFromString(t){return new Array(9).fill(0).map((e,n)=>new Array(9).fill(0).map((a,l)=>+t.charAt(n*9+l)))}static getUniverseFromGrid(t){return t.map(e=>e.map(n=>n===0?new Array(9).fill(0).map((a,l)=>l+1):[n]))}static getUniverseFromEmptyGrid(){return new Array(9).fill(0).map(()=>new Array(9).fill(0).map(f.MakeNewA19))}static getUniverseSize(t){return f.sum(t.map(e=>e.map(n=>n.length)).map(e=>f.sum(e)))}static sum(t){return t.reduce((e,n)=>e+n,0)}static getSquareList(t){let e=[];for(let n=0;n<9;n++){let a=[],l=Math.floor(n/3),c=n%3;[0,1,2].forEach(i=>[0,1,2].forEach(o=>a.push(t[l*3+i][c*3+o]))),e.push(a)}return e}static getXY(t){return{x:Math.floor(t/9),y:t%9}}};f.MakeNewA19=()=>new Array(9).fill(0).map((t,e)=>e+1);var s=f;function d(r){let t=[];for(let e=0;e<9;e++){let n=[];for(let a=0;a<9;a++)n.push(r[a][e]);t.push(n)}return t}var p=class r{static getLevel(t){return t.map(e=>e.map(n=>n.length).reduce((n,a)=>n+a,0)).reduce((e,n)=>e+n,0)}static removeRowDuplicate(t){t.forEach(e=>{let n=e.reduce((a,l)=>(l.length===1&&a.push(l[0]),a),[]);e.forEach(a=>{a.length>1&&n.forEach(l=>{let c=a.indexOf(l);c!==-1&&a.splice(c,1)})})})}static removeColDuplicate(t){let e=d(t);r.removeRowDuplicate(e)}static removeSquareDuplicate(t){let e=s.getSquareList(t);r.removeRowDuplicate(e)}};function w(r,t,e){return v(r,t,e)&&k(r,t,e)&&b(r,t,e)}function v(r,t,e){return r[t].indexOf(r[t][e])===e}function k(r,t,e){return r.map(a=>a[e]).indexOf(r[t][e])===t}function b(r,t,e){let n=r[t][e],a=Math.floor(t/3),l=Math.floor(e/3),c=r.slice(a*3,a*3+3).map(o=>o.slice(l*3,l*3+3));return c[t%3][e%3]=0,c.reduce((o,u)=>o.concat(u),[]).indexOf(n)===-1}var g={getSolutionStructure:s.initGrid,universe:new Array(9).fill(0).map(()=>new Array(9).fill(0).map(s.MakeNewA19)),getPossibilities:(r,t)=>{let{x:e,y:n}=s.getXY(t);return r[e][n]},resetPossibilities:(r,t,e)=>{let{x:n,y:a}=s.getXY(t);e[n][a].forEach(c=>r.push(c))},resetSolution:(r,t)=>{let{x:e,y:n}=s.getXY(t);r[e][n]=0},setSolution:(r,t,e)=>{let{x:n,y:a}=s.getXY(t);r[n][a]=e},checkSolution:(r,t)=>{let{x:e,y:n}=s.getXY(t);return w(r,e,n)},pop:r=>s.popRand(r),strategy:"find-first",max:2,length:81},m=class r{static from(t){return s.makeGridFromString(t)}static generate(){return g.universe=s.getUniverseFromEmptyGrid(),h(g)}static naiveCarve(t,e){let n,a=0;for(;;){n=JSON.parse(JSON.stringify(t));let l=new Array(81).fill(0).map((c,i)=>({r:Math.floor(i/9),c:i%9}));for(let c=0;c<e;c++){let{r:i,c:o}=s.popRand(l);n[i][o]=0}if(r.checkOneSolution(n))break;a++}return console.log("found in %d iterations",a),n}static checkOneSolution(t){return r.getAllSolution(t).length===1}static getAllSolution(t){let e=s.getUniverseFromGrid(t);e=r.humanSolve(e);let n={...g,universe:e,strategy:"find-all",max:2,length:81};return h(n)}static humanSolve(t){let e=s.deepClone(t),n,a=s.getUniverseSize(e);do n=a,p.removeRowDuplicate(e),p.removeColDuplicate(e),p.removeSquareDuplicate(e),a=s.getUniverseSize(e);while(a<n);return e}static carve(t,e){return r.btcarve(t,e)}static btcarve(t,e){for(;;)try{let n,a=new Array(e).fill(0).map(()=>new Array(81).fill(0).map((i,o)=>({row:Math.floor(o/9),col:o%9}))),c=h({getSolutionStructure:()=>[],universe:a,getPossibilities:(i,o)=>i[o],resetPossibilities:(i,o,u)=>{u[o].forEach(S=>i.push(S))},resetSolution:(i,o)=>{i.pop()},setSolution:(i,o,u)=>{if(i.length===o){i[o-1]=u;return}if(i.length===o-1){i.push(u);return}},checkSolution:(i,o)=>{let u=i[o-1];return i.findIndex(y=>y.row===u.row&&y.col===u.col)!==o-1?!1:(n=JSON.parse(JSON.stringify(t)),i.forEach(y=>{n[y.row][y.col]=0}),r.checkOneSolution(n))},pop:i=>s.popRand(i),strategy:"find-first",maxIteration:500,length:e});if(n=JSON.parse(JSON.stringify(t)),c.forEach(i=>{n[i.row][i.col]=0}),!r.checkOneSolution(n))throw new Error("I am buggy");return n}catch(n){console.log("e",n.message)}}};addEventListener("message",({data:r})=>{let t=m.generate(),e=m.carve(t,r.number_of_empty);postMessage({solution:t,masked:e})});
